<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <link rel="icon"       href="ASSETS/favicon.ico">
    <title>GLIDE - GameLang IDE</title>
</head>
<body>
    <script type="module" src="script.js" ></script>
    <div id="contentWrapper">    
        <center><div id="EditorContainer"></div>
        
        <div id="ButtonsGUI">
            <button id="run_button" class="GUIbtn"></button>
            <button id="print_button" class="GUIbtn"></button>
            <button id="clear_button" class="GUIbtn"></button>
        </div>

        <h1>GAMELANG : an overview</h1>
        <div id="tutorialContent">
        Hi! This is meant as an introduction / explanation for my proof-of-concept language: <strong>GAMELANG</strong><br>
        Let's start with the basics:<br>
            <div id="section">
                <p id="sectionTitle">Whitespace</p>
                Spaces are the foundation of parsing for this language, an item (or "token") to be distinguishable from its neighbours must be well spaced out on both sides.<br>
                That said indentation is instead irrelevant, just like the <strong>amount</strong> of spaces you leave around your tokens.
            </div>

            <div id="section">
                <p id="sectionTitle">Types</p>
                GAMELANG is a dynamicly typed, interpreted and synchronous language with only four proper primitive types:
                <ul>
                    <li>
                        <strong>NUMBER</strong> - GAMELANG does not distinguish between numbers and booleans, namely:
                        0 ←→ false,<br> 1 ←→ true.
                    </li>
                    
                    <li>
                        <strong>STRING</strong> - Currently, support for escaping characters is limited to "&new",
                        which replaces the much more common "\n".
                        <div class="codeSnippet"><pre>
                            \"Hello, World!&newWhat's up?" # >> Hello, World!
                            \                              # What's up?
                        </pre></div>
                    </li>
                    
                    <li>
                        <strong>LIST</strong> - A collection of indexable items, of any type (even other lists).
                    </li>
                    
                    <li>
                        <strong>OBJECT</strong> - A collection of "property : value" pairs that have to be indexed by name and are not positional.
                        Object properties are more precisely called "methods" if their access operation corresponds to a "Function call", but we'll get
                        to that later.
                    </li>
                </ul>
                Items of types LIST or OBJECT aren't just values, they have a sort of "identity" to them, which means that they can be passed by reference other than by value.<br>
                What you can also notice is the absence of a <strong>NULL</strong> type of sorts. In fact, such values aren't allowed in the language and while it's possible
                to create an empty string ("") similar structures for other types, such as an empty list ([]) or object ({}), are impossible to obtain.
            </div>

            <div id="section">
                <p id="sectionTitle">Expressions</p>
                Any line of code written in GAMELANG is called an <strong>Expression</strong>, of which there are 3 valid types:
                <ul>
                    <li>
                        <strong>Procedures:</strong> a procedure, like any other expression, follows a specific pattern of arguments and
                        syntactic rules. Most notably, it always begins with a <strong>keyword</strong>.<br>
                        This is a list of all currently available keywords:
                        <table><tr>
                            <td width="15%">
                                <ul class="chapterList">
                                    <li class="chapter pk" selected="true">print</li>
                                    <li class="chapter pk">make    </strong></li>
                                    <li class="chapter pk">free    </strong></li>
                                    <li class="chapter pk">when    </strong></li>
                                    <li class="chapter pk">else    </strong></li>
                                    <li class="chapter pk">match   </strong></li>
                                    <li class="chapter pk">loop    </strong></li>
                                    <li class="chapter pk">next    </strong></li>
                                    <li class="chapter pk">exit    </strong></li>
                                    <li class="chapter pk">def     </strong></li>
                                    <li class="chapter pk">use     </strong></li>
                                    <li class="chapter pk">with    </strong></li>
                                    <li class="chapter pk">replace </strong></li>
                                    <li class="chapter pk">flag    </strong></li>
                                </ul>
                            </td>

                            <td>
                                <div class="insertContent" id="CHAPTERCONTAINER-procedures"><div id="innerContainer">
                                    <div id="print" style="display: inline;">
                                        <strong>Syntax: </strong><font class="definition">&ltPrint&gt := print &ltStackExpression&gt</font><br>
                                        <strong>Usage:  </strong> Prints its value to the console.<br><br>

                                        This is the first procedure we tackle, so let's begin by looking at a couple examples:<br>
                                        <div class="codeSnippet"><pre>
                                            \print 2               # this value is a NUMBER
                                            \print "Hello, World!" # this value is a STRING
                                            \print 1 2 "hi" 3      # these values are MANY >> [ 1, 2, hi, 3 ]
                                        </pre></div><br>
                                        As you can see in example #3, multiple values can share the same space with no separators.
                                        Moreover, since we aren't performing any operations on them we're left with many values to process,
                                        and when this happens what you obtain is a <strong>LIST</strong>. To understand why this happens, we need to talk
                                        about the only (not entirely true) argument this procedure takes in: a <strong>stack expression</strong>.<br><br>

                                        Stack expressions are the way values are created, changed and manipulated in this language. Anytime a value is written,
                                        transferred, changed, calculated or even taken as an input from the user, it's bound to pass through a stack expression..
                                        so how does it work?<br>
                                        Every time a stack expression argument is executed, 3 things happen in order:<br>
                                        <div class="manualList">
                                            1) An empty stack is created. A <strong>stack</strong> in computer science is a very common abstract data structure defined as a pile 
                                            of elements that can only be accessed from its "top", removing or adding one element at a time. In this particular implementation, many more
                                            operations are possible, however the core limitation of not being able to access any of the elements at a moment's notice is still present, and
                                            it makes for an original and compelling coding style.
                                            <br><br>
                                            
                                            2) All the items in the stack expression are evaluated in writing order. A direct consequence of using a stack to store values is what's known in
                                            Mathematics as <strong>Reverse Polish Notation</strong>, a particular way of writing expressions where each operator goes after all of its operands.<br>
                                            This means that to perform an addition we must first push both inputs on the stack, and only then the "+" follows.<br>
                                            Reverse polish notation ensures linear priority in evaluating mathematical and logical operations, making them always inequivocably objective.
                                            How many times have people been fooled by "simple operations" such as this one: <strong>1 + 12 / 2 * 3</strong> ? Does this equal 19 or 3? Depends who you ask,
                                            because "/" is a terrible way of indicating division given it's <strong>unclear</strong> what the numerator and denominator are.
                                            Most programming languages solve this problem by relying on parentheses, forcing you to use them everywhere in fear of messing up the
                                            order of operations in complex expressions. Here there are no parentheses, you don't need them, priority is <strong>linear</strong>.
                                            <br><br>
                                            
                                            3) What remains in the stack is "dumped" into its container element, which in this case is the <font class="pk">print</font> procedure. The so-called "dumping" phase does
                                            different things based on the amount of elements left on the stack: since there is no NULL type no stack expression is ever allowed to end its evaluation
                                            empty, but besides that everytime the output of a stack expression is comprised of multiple elements it gets automatically cast to a LIST.
                                        </div>
                                        <div class="deeper">Going deeper:</div> the optional syntax: <font class="definition">&ltPrint&gt := print &ltStackExpression&gt with &ltStackExpression&gt</font>
                                        allows you to style the printed text to some degree, here's how:
                                        <ul>
                                            <li>The stack expression containing style specifications must evaluate to a string to be valid.</li>
                                            <li>A valid style-string starts with a colour, which can be either in full hexadecimal notation (#rrbbgg) or written with its common name.
                                            This last approach, although valid, is discouraged because I can't be bothered to waste space listing all the available colours.
                                            </li>
                                            <li>After the colour has been specified, there are a few modifiers you can add to your string (in no particular order), separated from
                                                the colour and each other by a space:
                                                <ul>
                                                    <li><strong>bold</strong></li>
                                                    <li><i>italic</i></li>
                                                    <li><u>underline</u></li>
                                                </ul>
                                            </li>
                                        </ul>
                                        Here's how an example featuring all the styling options might look like:
                                        <div class="codeSnippet"><pre>
                                            \print "Hello, world!" with "red bold italic underline"
                                        </pre></div>
                                    </div>

                                    <div id="make" style="display: none">
                                        <strong>Syntax: </strong><font class="definition">&ltMake&gt := make &ltAssignment&gt </font><br>
                                        <strong>Usage:  </strong> Creates a new variable.<br><br>

                                        If you take a peek further down in this chapter about expressions, you will find that assignments are, just like procedures,
                                        a valid expression type. For this very reason we won't spend too much time explaining how this procedure's only argument works
                                        in detail, but in a nutshell an assignment follows this syntax:<br>
                                        <font class="definition">&ltAssignment&gt := &ltTarget&gt &ltAssignmentSymbol&gt &ltStackExpression&gt</font><br>
                                        Where the <strong>target</strong>, for simplicity, can be interpreted as the name you want to give to your variable. To be exact,
                                        you could also assign values to properties inside of an object or to specific elements inside a list, however this is not allowed in
                                        a <font class="pk">make</font> procedure, whose only purpose is to create a new, indipendent piece of data.<br><br>

                                        There are 2 more things regarding assignments that you have to watch out for when using a <font class="pk">make</font> procedure:
                                        <ul>
                                            <li><strong>Strict assignment</strong> - the simplest kind of assignment, where the so-called <strong>assignment symbol</strong>
                                            is "=", and the only one allowed in <font class="pk">make</font> procedures. Without going into too much detail, any non-strict assignment needs its target
                                            argument to already have a value to start from so that it can get modified, and this is obviously not possible if the variable hasn't
                                            been fully declared yet.
                                            </li>
                                            
                                            <li><strong>Implicit assignment</strong> - by omitting the assignment symbol and the stack expression, the value of your newly created
                                            variable is automatically set to 0. This is simply syntax sugar that looks no different from any other strict assignment to zero after the
                                            parsing phase, and while nothing "logically" stops this from existing even outside of <font class="pk">make</font> procedures, I feel like an expression only containing
                                            one word (the name of your variable) would look ugly and unclear.
                                            </li>
                                        </ul>
                                        
                                        With all this in mind, let's see some examples:<br>
                                        <div class="codeSnippet"><pre>
                                            \make  foo = "bar" # the variable 'foo' has been created
                                            \print foo         # >> bar

                                            \make a     # implicit assignment
                                            \make b = 0 # this is equivalent to the previous line
                                        </pre></div><br>

                                        One last thing: we've learned that we can control both the name and the value of any variable we create, however variables also have a third parameter
                                        called "depth", which simply refers to the <strong>scope</strong> they were created in. So far, all the variables we can declare are part of the so-called
                                        <strong>global</strong> scope, because to be fair we don't even know what a scope is... let's change that. A scope is simply the space enclosed by a 
                                        <strong>block</strong>, an argument common to many procedures we have yet to see and that is defined as:
                                        <font class="definition">&ltBlock&gt := { ( &ltExpression&gt )* }</font> , so basically a chunk of code within curly brackets.<br>
                                        Every time a block is opened a private scope is created, and any variable declared inside of it will have a depth equal to how many levels of nesting separate
                                        it from the global scope. Furthermore, when the block closes all the variables that were declared inside of it are automatically deleted, they disappear together with their scope.
                                        In a practical sense, this means that wherever you are in your code you are only allowed to access variables whose depth is bigger or equal to the current scope, 
                                        or in other words "less private" variables.<br>
                                        This is important because it's not possible to have two variables with the same name <strong>defined in the same scope</strong>, but when legal name collisions do occur
                                        the program will always prioritize the variable with the most depth:<br>
                                        <div class="codeSnippet"><pre>
                                            \make a = 14  # depth : global(0)
                                            \make a = 15  # this is not allowed! this new "a" is in the same scope as another 
                                            \             # variable with the same name
                                            \
                                            \{ # you are not actually allowed to treat blocks as expressions, just imagine this is a private scope
                                            \
                                            \   print a      # >> 14
                                            \   make  a = 26 # this is fine, this new "a" has a depth of 1
                                            \   print a      # >> 26 , the more private "a" is prioritized
                                            \}
                                            \
                                            \print a # >> 14 , the other "a" was deleted when the block closed
                                        </pre></div><br>

                                        <div class="deeper">Going deeper:</div> Use the <strong>$global</strong> specifier to make sure your variable is instanciated
                                        in the global scope no matter what:
                                        <div class="codeSnippet"><pre>
                                            \{
                                            \   make $global foo = 25 # depth : 0
                                            \   make  foo = 9         # depth : 1
                                            \   print foo             # >> 9
                                            \}
                                            \
                                            \print foo # >> 25
                                        </pre></div>
                                    </div>

                                    <div id="free" style="display: none">
                                        <strong>Syntax: </strong><font class="definition">&ltFree&gt := free WORD</font><br>
                                        <strong>Usage:  </strong> Deletes an existing variable.<br><br>

                                        Cannot be used to delete properties of objects or specific items in lists. Scope priority works the same everytime you write a variable's
                                        name in a stack expression, and in this case if multiple variables with the same name are present, the deleted one will be the most private.<br><br>
                                        
                                        Examples:<br>
                                        <div class="codeSnippet"><pre>
                                            \make  foo = "bar"
                                            \print foo # >> bar
                                            \free  foo
                                            \print foo # Error!
                                        </pre></div><br>
                                    </div>

                                    <div id="when" style="display: none">
                                        <strong>Syntax: </strong><font class="definition">&ltWhen&gt := when &ltStackExpression&gt ( loop )? &ltBlock&gt</font><br>
                                        <strong>Usage:  </strong> Conditional or iterative statement, encapsulates code to be run only when a condition is met.
                                        If the "loop" argument is present, the condition is evaluated at every iteration, stopping the loop upon failure.</br><br>

                                        This is one of the most confusing procedures when starting out with this language due to the fact that it stands in for both an
                                        "if" statement and a "while" loop, but why would I even choose to aggregate these two behaviours in the first place?<br>
                                        At its core, the <font class="pk">when</font> procedure is a way of executing some code (contained in its block argument) conditionally, or in other words
                                        only if its stack expression evaluates to a truthy value. But wait: if there are no booleans, then what is true? The only thing that matters
                                        is that the stack expression argument ultimately evaluates to a NUMBER, then anything different from 0 is considered true. If the condition
                                        turns out to be false instead, the evaluation continues down the so-called <strong>else chain</strong> (if present), explained in
                                        detail in the next procedure chapter of this list.<br><br>
                                        If you think about it, a "while" loop is nothing more than a conditional statement that repeats as long as it evaluates truthfully, which
                                        is why I opted for this condensed syntactical approach; and it's not confusing either, with the <font class="pk">loop</font> argument acting as a
                                        clear distinction between the two types of statements. Moreover, the possibility to have an <font class="pk">else</font> chain even after a conditional loop seems
                                        less weird with this approach. Keep in mind however, that <font class="pk">else</font> procedures can never loop.<br><br>
                                        
                                        Here are some examples:<br>
                                        <div class="codeSnippet"><pre>
                                            \make password = "secretKey"
                                            \when password "secretKey" == { # the arguments to this equality (==) operation are STRINGs, but the operation itself can result in either 1 or 0, which makes the stack expression valid as a condition
                                            \   print "correct password entered!"
                                            \}
                                            \
                                            \make a = 5
                                            \when a loop {
                                            \   print a   # >> 5 >> 4 >> 3 >> 2 >> 1
                                            \   a = a 1 - # very important, otherwise the loop never stops!
                                            \}
                                        </pre></div><br>
                                    </div>

                                    <div id="else" style="display: none">
                                        <strong>Syntax: </strong><font class="definition">&ltElse&gt := else ( &ltWhen&gt | &ltBlock&gt ) </font><br>
                                        <strong>Usage:  </strong> Conditional statement, encapsulates code to be run only when a previous conditional statement has failed.<br><br>

                                        <font class="pk">Else</font> procedures only exist as an extension to <font class="pk">when</font> procedures, in no case can they appear without a prior conditional statement. As the syntax
                                        suggests, <font class="pk">else</font> procedures can be followed by either a whole other <font class="pk">when</font> procedure, which is simply a way of saying they can have a condition of
                                        their own, or by just a block, and in the latter case the <font class="pk">else</font> procedure will run anytime the prior condition fails.<br>
                                        This informal distinction between "else when" and "else" is made in many other programming languages as well, and just like in all of them it's
                                        perfectly fine to have a sequence of fallback conditions forming an <strong>else chain</strong> that, logically, must place all the optional
                                        "else when"s before the "else" (which, again by pure logic, can only appear once).<br><br>

                                        As I've already mentioned, <font class="pk">when</font> procedures that act as arguments in else chains cannot loop, and the else chain on a "when-loop" procedure is only
                                        ever considered if the loop never starts because the condition was false from the start. For example:<br>
                                        <div class="codeSnippet"><pre>
                                            \make a = 3
                                            \when a 2 == {
                                            \   print "a is 2"
                                            \}
                                            \else when a 0 &lt; == {
                                            \   print "a is negative"
                                            \}
                                            \else {
                                            \   print "a is between 0 and 2 or bigger than 2" # this will run
                                            \}
                                            \
                                            \when a loop {
                                            \   print a
                                            \   a = a 1 -
                                            \}
                                            \else {
                                            \   print "this only runs if a is 0 when the loop first runs" # in our case it won't
                                            \}
                                        </pre></div><br>
                                    </div>

                                    <div id="match" style="display: none">
                                        <strong>Syntax: </strong><font class="definition">&ltMatch&gt := match &ltStackExpression&gt &ltBlock&gt</font><br>
                                        <strong>Usage:  </strong> Switch statement, encapsulates conditional statements that act as alternatives for a value. The matching conditional statement will run.<br><br>

                                        The <font class="pk">match</font> procedure is a relatively new addition to the language, still it manages to handle switch-like logic recycling familiar syntax and
                                        arguments from other very common procedures. To achieve this, some strict requirements are to be met to ensure that this procedure's arguments
                                        are valid:
                                        <ul>
                                            <li>
                                                <strong>The stack expression must evaluate to a single value</strong> - this argument is supposed to provide a value for the cases
                                                to check against (the option value), and to do so behind the scenes an equality operation occurs using the == stack operator. At this
                                                point you might have no idea of what I'm talking about, but all you need to know is that this operation only accepts items of type NUMBER
                                                or STRING, which means that our stack expression (and all of those in the different cases too) must also produce a value of either type.
                                            </li>

                                            <li>
                                                <strong>The block must only contain valid "case" expressions</strong> - where a "case" is none other than a <font class="pk">when</font>
                                                procedure whose stack expression is bound by the same rule from before. Moreover, the only <font class="pk">when</font> procedure allowed
                                                to have an <font class="pk">else</font> is the last one, where the <font class="pk">else</font> acts as the "default" case of the switch
                                                statement and thus cannot have a condition of his own. Cases are checked one by one against the option value in order from top to bottom,
                                                until a match is found: then, the code inside of that case's block can run. Whenever nothing matches, the <font class="pk">else</font>
                                                procedure acting as the default case will run if present.<br>
                                                <div class="codeSnippet"><pre>
                                                    \{
                                                    \   when 2 { ... }
                                                    \   else   { ... } # this is WRONG: the default else case is not at the end
                                                    \   when 3 { ... }
                                                    \}
                                                    \
                                                    \{
                                                    \   when 2 { ... }
                                                    \   when 3 { ... }
                                                    \   else when 4 { ... } # this is WRONG: the default else case has a condition 
                                                    \}
                                                    \
                                                    \{
                                                    \   when 2 loop { ... } # this is WRONG: when procedures used as cases cannot loop
                                                    \   when 3 { ... }    
                                                    \}
                                                </pre></div>
                                            </li>

                                            <li><strong>There cannot be two or more cases that evaluate to the same value</strong></li>
                                        </ul>

                                        Here's an example with correct syntax to clarify what it should look like:<br>
                                        <div class="codeSnippet"><pre>
                                            \make i = 1
                                            \match i {
                                            \   when 0 { print "i was zero" }
                                            \   when 1 { print "i was one"  } # this will run
                                            \   when 2 { print "i was two"  }
                                            \   else   { print "i was negative or bigger than two" }
                                            \}
                                        </pre></div>
                                    </div>

                                    <div id="loop" style="display: none">
                                        <strong>Syntax: </strong><font class="definition">&ltLoop&gt := loop &ltStackExpression&gt &ltBlock&gt</font><br>
                                        <strong>Usage:  </strong> Iterative statement, encapsulates code to be run a set number of times.<br><br>

                                        This basic procedure implements the age old "for" loop with a simpler syntax, asking you to specify directly the number of times your
                                        loop is supposed to run via its stack expression argument. This obviously implies that said argument must evaluate to a single numeric value to
                                        classify as valid.<br><br>

                                        Keep in mind that all the blocks we've seen so far act the same as far as scope privacy is concerned, which means that declaring variables inside of
                                        loops does not result in any collision, as all inner variables are freed before the next iteration starts:<br>
                                        <div class="codeSnippet"><pre>
                                            \make i
                                            \loop 5 {
                                            \   make y = i 3 *   
                                            \   print y # >> 0 >> 3 >> 6 >> 9 >> 12
                                            \   i = i 1 +
                                            \}
                                        </pre></div><br>
                                        
                                        <div class="deeper">Going deeper:</div> To be completely fair the more common for loop approach where you define an iterator variable and tell
                                        the loop where to start and stop is not all that terrible, yet having a very straightforward and readable syntax is also very compelling.
                                        The optional syntax <font class="definition">&ltLoop&gt := loop &ltStackExpression&gt with &ltAssignment&gt &ltBlock&gt</font> allows you to get the
                                        best of both worlds by implicitly declaring a variable, entirely private within the loop, that will automatically count up by one after every
                                        iteration. This is still a bit limited, but it works well for the most common cases. After all, it's just syntax sugar that disappears during the
                                        parsing phase, and this is the kind of conversion that you're getting:<br>
                                        <div class="codeSnippet"><pre>
                                            \loop 5 with i = 2 { print i }
                                            \
                                            \# is converted to..
                                            \
                                            \when 1 {
                                            \   make i = 1 # the initial value is 1 lower than expected, because we update i at the beginning of every iteration
                                            \   loop 5 {
                                            \      i = i 1 + # and we have to update it here to make sure the user cannot tamper with this process before it happens
                                            \      print i
                                            \   }
                                            \}
                                        </pre></div><br>

                                        That always-true <font class="pk">when</font> procedure around the loop acts as a container, making sure that "i" is both deleted after the loop but
                                        also created with a depth unique to itself so that there is no risk of name collisions. This is important, because the actual syntax makes it seem
                                        like "i" exists only inside of the loop, and this is the only way to convey that.<br>
                                        The assignment argument can be implicit and has to be strict, just like in any <font class="pk">make</font> procedure, and it cannot be globalized.<br><br>

                                        To close the chapter neatly, let's look at a famous example that is also featured in the <strong>\EXAMPLES</strong> folder for this project,
                                        although with a slightly different implementation:<br>
                                        <div class="codeSnippet"><pre>
                                            \# FizzBuzz!
                                            \
                                            \loop 99 with i = 1 { # when trying this yourself, mind that the % operator is not readily available
                                            \   make buffer = ""
                                            \   when i 3 % 0 ==   { buffer = "Fizz" }
                                            \   when i 5 % 0 ==   { buffer = buffer "Buzz" + }
                                            \   when buffer "" == { buffer = i }
                                            \   print buffer
                                            \}
                                        </pre></div>
                                    </div>

                                    <div id="next" style="display: none">
                                        <strong>Syntax: </strong><font class="definition">&ltNext&gt := next</font><br>
                                        <strong>Usage:  </strong> Inside of an iterative statement it skips to the next iteration.<br><br>

                                        A very straightforward "continue" implementation that cannot be used outside of loops. A couple of examples:<br>
                                        <div class="codeSnippet"><pre>
                                            \# print only positive numbers
                                            \make nums = 3 -5 4 12 -8 0.4 0 13
                                            \
                                            \loop nums range with i { # the "range" stack operator tells you the length of a LIST item, but it's not readily available 
                                            \   make n = nums[ i ] # don't panic! this is a sneak peek into list indexing
                                            \   when n 0 &lt;= { next }
                                            \   print n
                                            \}
                                        </pre></div><br>
                                        
                                        <div class="deeper">Going deeper:</div> As you can see, the <font class="pk">next</font> procedure in the example above is not <strong>directly</strong> inside of a looping
                                        block, but as long as somewhere in the nesting such a structure exists, then it will work. At runtime, the compiler keeps track of all
                                        currently open loops, and the one affected by control-flow procedures like <font class="pk">next</font> and <font class="pk">exit</font>
                                        (next chapter) is the one that's closest to it, which is always the most "inner" one in code and the top one in the stack.
                                    </div>

                                    <div id="exit" style="display: none">
                                        <strong>Syntax: </strong><font class="definition">&ltExit&gt := exit ( &ltStackExpression&gt )?</font><br>
                                        <strong>Usage:  </strong> Inside of an iterative statement it forcefully terminates it, inside of a function
                                        it acts as a return statement.<br><br>

                                        Examples:<br>
                                        <div class="codeSnippet"><pre>
                                            
                                        </pre></div><br>
                                        ??
                                    </div>

                                    <div id="def" style="display: none">
                                        <strong>Syntax: </strong><font class="definition">&ltDefine&gt := def WORD ( ( => | with ) &ltStackExpression&gt )? &ltBlock&gt</font><br>
                                        <strong>Usage:  </strong> Defines a function, encapsulating code to be run when a call is executed.<br><br>

                                        Examples:<br>
                                        <div class="codeSnippet"><pre>
                                            
                                        </pre></div><br>
                                        ??
                                    </div>

                                    <div id="use" style="display: none">
                                        <strong>Syntax: </strong><font class="definition">&ltUse&gt := use STRING with WORD</font><br>
                                        <strong>Usage:  </strong> Loads a module in the form of a variable of type OBJECT.<br><br>

                                        Examples:<br>
                                        <div class="codeSnippet"><pre>
                                            
                                        </pre></div><br>
                                        ??
                                    </div>

                                    <div id="with" style="display: none">
                                        <strong>Usage:</strong> As argument.<br><br>

                                        Examples:<br>
                                        <div class="codeSnippet"><pre>
                                            
                                        </pre></div><br>
                                        ??
                                    </div>

                                    <div id="replace" style="display: none">
                                        <strong>Syntax: </strong><font class="definition">&ltReplace&gt := replace WORD ( with | = ) &ltStackExpression&gt</font><br>
                                        <strong>Usage:  </strong> Creates a macro stack operator.<br><br>

                                        Examples:<br>
                                        <div class="codeSnippet"><pre>
                                            
                                        </pre></div><br>
                                        ??
                                    </div>

                                    <div id="flag" style="display: none">
                                        <strong>Syntax: </strong><font class="definition">&ltFlag&gt := flag &ltStackExpression&gt </font><br>
                                        <strong>Usage:  </strong> Raises an exception to the console.<br><br>

                                        Examples:<br>
                                        <div class="codeSnippet"><pre>
                                            
                                        </pre></div><br>
                                        ??
                                    </div>
                                </div></div>
                            </td>
                        </tr></table>
                    </li>
                    <li>
                        <strong>Function Calls:</strong> ??
                    </li>
                    <li>
                        <strong>Assignments:</strong> ??
                    </li>
                </ul> 
            </div>
        </div></center>
    </div>
</body>
</html>